<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Aminams</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            background-color: rgb(50, 50, 60);
        }
        #canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }
        .options {
            left: 2%;
            top: 4%;
            width: auto;
            height: auto;
            display: flex;
            flex-direction: column;
            justify-content: start;
            align-items: start;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            z-index: 10;
            color: #ddd;
            font-weight: bold;
            font-size: 20px;
            margin: 20px;
        }
        .options input, .options select {
            margin: 2px;
            margin-bottom: 10px;
            border: 0;
            border-radius: 3px;
            background-color: #ddd;
        }
        .options input[type=range] {
            margin: 0;
        }
        .options label {
            margin: 2px;
            margin-top: 10px;
        }
        .options h2 {
            margin-bottom: 20px;
        }
        .options button {
            transition: background-color 0.1s ease;
            margin: 2px;
            margin-top: 10px;
            margin-bottom: 10px;
            border: 0;
            border-radius: 3px;
            background-color: #ddd;

            &:hover {
                background-color: #bbb;
            }
            &:active {
                background-color: #999;
            }
        }
        .score {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: start;
            align-items: center;
        }
        .score h1, h2 {
            margin: 0;
            margin-top: 10px;
            color: #eee;
            font-weight: bold;
        }
        .hidden {
            display: none;
        }
        .options .danger {
            &:hover {
                background: rgb(190, 49, 49);
            }
            &:active {
                background: rgb(122, 31, 31);
            }
        }
        .options .hidebutton {
            margin: 0;
            margin-top: 10px;
            width: 100%;
            color: #bbb;
            background: rgba(0, 0, 0, .5);
            &:hover {
                background: rgba(0, 0, 0, .7);
            }
            &:active {
                background: rgba(0, 0, 0, .8);
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="1920" height="1080"></canvas>
    <div class="score">
        <h1 id="scoretext">Score: 0</h1>
        <h2 id="bestscoretext">Best: 0</h2>
    </div>
    <div style="position: absolute; left: 0; top: 0; width: 100%; height: 100%; display: flex; flex-direction: row; justify-content: start; align-items: start;">
        <div class="options" style="padding: 0; background-color: transparent;">
            <div class="options" style="margin: 0;" id="d1">
                <h2>Options</h2>

                <label for="speed">Speed</label>
                <input id="speed" type="number" value="5" onchange="speed = this.value; localStorage.setItem('speed', this.value)">

                <label for="rotataionspeed">Rotation Speed</label>
                <input id="rotationspeed" type="number" value="5" onchange="rotationSpeed = this.value; localStorage.setItem('rotationSpeed', this.value)">

                <label for="distance" title="Distance between dots">Distance</label>
                <input id="distance" type="number" value="5" onchange="distance = this.value; localStorage.setItem('distance', this.value)">
                
                <label for="length" title="">Length</label>
                <input id="length" type="number" value="5" onchange="length = this.value; localStorage.setItem('length', this.value)">

                <button onclick="document.getElementById('visualoptions').classList.toggle('hidden')">Visual</button>

                <button onclick="document.getElementById('informationoptions').classList.toggle('hidden')">Info</button>
                
                <button onclick="document.getElementById('miscoptions').classList.toggle('hidden')">Misc</button>

                <button onclick="creature.reset()">Reset</button>
            </div>

            <button onclick="document.getElementById('d1').classList.toggle('hidden'); this.innerHTML = this.innerHTML == '/\\' ? '\\/' : '/\\'; document.getElementById('d2').classList.toggle('hidden')" class="hidebutton">/\</button>
        </div>
        <div class="options hidden" id="visualoptions">
            <h2>Visual</h2>

            <label for="backgroundcolor">Background Color</label>
            <input id="backgroundcolor" type="color" value="#33333f" oninput="document.body.style.backgroundColor = this.value; localStorage.setItem('backgroundColor', this.value)">

            <label for="bodycolor">Body Color</label>
            <input id="bodycolor" type="color" value="#f5f5f5" oninput="creature.bodyColor = this.value; localStorage.setItem('bodyColor', this.value)">

            <label for="outlinecolor">Outline Color</label>
            <input id="outlinecolor" type="color" value="#111111" oninput="creature.outlineColor = this.value; localStorage.setItem('outlineColor', this.value)">

            <label for="eyecolor">Eyes Color</label>
            <input id="eyecolor" type="color" value="#111111" oninput="creature.eyeColor = this.value; localStorage.setItem('eyeColor', this.value)">

            <label for="applecolor">Apple Color</label>
            <input id="applecolor" type="color" value="#bb3333" oninput="apple.color = this.value; localStorage.setItem('appleColor', this.value)">

            <label for="drawmode" title="">Drawmode</label>
            <select id="drawmode" onchange="creature.drawmode = this.value; localStorage.setItem('drawmode', this.value)">
                <option value="circles">Circles</option>
                <option value="lines">Lines</option>
            </select>
            
            <label for="debug" title="">Extended</label>
            <input id="debug" type="checkbox" value="0" onchange="this.value = this.value == '0' ? '1' : '0'; creature.debug = parseInt(this.value)">

            <label for="shape" title="">Shape</label>
            <select id="shape" onchange="creature.shape = this.value; localStorage.setItem('shape', this.value);
                                         if (this.value == 'sin') document.getElementById('sinfrequency').classList.remove('hidden'); else document.getElementById('sinfrequency').classList.add('hidden')
                                         if (this.value == 'sin') document.getElementById('sinfrequencylabel').classList.remove('hidden'); else document.getElementById('sinfrequencylabel').classList.add('hidden')">
                <option value="linear">Linear</option>
                <option value="exp">Exp</option>
                <option value="sin">Sin</option>
            </select>

            <label for="sinfrequency" id="sinfrequencylabel">Sin Frequency</label>
            <input id="sinfrequency" type="number" value="5" oninput="sinFrequency = this.value; localStorage.setItem('sinfrequency', this.value)">
        </div>
        <div class="options hidden" id="informationoptions">
            <h2>Information</h2>

            <label for="headpositionx">Head Position X</label>
            <input disabled id="headpositionx" type="number">

            <label for="headpositiony">Head Position Y</label>
            <input disabled id="headpositiony" type="number">

            <label for="fps">FPS</label>
            <input disabled id="fps" type="number">

            <label for="maxfps">Max FPS</label>
            <input id="maxfps" type="number" onchange="this.value = Math.min(Math.max(this.value, 1), 120); localStorage.setItem('maxfps', this.value); clearInterval(updateInterval); updateInterval = setInterval(update, 1000 / this.value)">
        </div>
        <div class="options hidden" id="miscoptions">
            <h2>Misc</h2>

            <button onclick="localStorage.setItem('bestScore', 0); bestScore = 0; creature.reset()">Reset Best Score</button>

            <button onclick="localStorage.clear(); bestScore = 0; creature.reset()" class="danger">Reset All</button>
        </div>
    </div>

    <script>

        var scales = [30, 32, 34, 36, 38];
        var positions = [];
        var keys = {};
        var direction = 0;
        var frames = 0;
        var score = 0;
        var sinFrequency = 5;
        var bestScore = localStorage.getItem('bestScore') || 0;
        var scales = [30, 32, 34, 36, 38];

        var canvas = document.getElementById("canvas");
        var ctx = canvas.getContext("2d");

        var bodyColor = localStorage.getItem('bodyColor') || "#f5f5f5";
        document.getElementById("bodycolor").value = bodyColor;

        var outlineColor = localStorage.getItem('outlineColor') || "#111111";
        document.getElementById("outlinecolor").value = outlineColor;

        var eyeColor = localStorage.getItem('eyeColor') || "#111111";
        document.getElementById("eyecolor").value = eyeColor;

        var speed = localStorage.getItem('speed') || 10;
        document.getElementById("speed").value = speed;

        var rotationSpeed = localStorage.getItem('rotationSpeed') || 10;
        document.getElementById("rotationspeed").value = rotationSpeed;

        var distance = localStorage.getItem('distance') || 10;
        document.getElementById("distance").value = distance;

        var length = localStorage.getItem('length') || 200;
        document.getElementById("length").value = length;

        document.body.style.backgroundColor = localStorage.getItem('backgroundColor') || "#33333f";

        document.getElementById("drawmode").value = localStorage.getItem('drawmode') || "circles";

        document.getElementById("applecolor").value = localStorage.getItem('appleColor') || "circles";
        
        document.getElementById("maxfps").value = localStorage.getItem('maxfps') || 60;

        document.getElementById("bestscoretext").innerHTML = "Best: " + bestScore;

        document.getElementById("shape").value = localStorage.getItem('shape') || "linear";
        
        for(let i = 0; i < length; i++) {
            //scales.push(40 - i * 30 / length);
        }
        for(let i = 0; i < scales.length; i++) {
            positions[i] = [- i * distance + window.innerWidth / 2, window.innerHeight / 2];
        }


        window.addEventListener('resize', resize, true)
        resize()
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.strokeStyle = "black";
            ctx.lineWidth = 10;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            console.log(window.innerWidth, innerHeight);
        }

        class Creature {
            constructor(x=0, y=0, scales, distance, speed, rotationSpeed, bodyColor, outlineColor, eyeColor, length = 1000, direction = 0, drawmode, shape) {
                this.x = x;
                this.y = y;
                this.scales = scales;
                this.distance = distance;
                this.speed = speed;
                this.direction = direction;
                this.rotationSpeed = rotationSpeed;
                this.bodyColor = bodyColor;
                this.outlineColor = outlineColor;
                this.eyeColor = eyeColor;
                this.length = length;
                this.drawmode = drawmode || localStorage.getItem('drawmode') || "circles";
                this.shape = shape || localStorage.getItem('shape') || "linear";
                this.debug = false;

                this.scales = [30, 32, 34, 36, 38];
                for(let i = 0; i < this.length; i++) {
                    if (this.shape == "linear") this.scales.push(Math.abs( 40 - i * 30 / this.length));
                    else if (this.shape == "exp") this.scales.push(Math.abs( 40 - i * 30 / this.length) ** 2);
                    else if (this.shape == "sin") this.scales.push(Math.abs( 40 - Math.sin(i * this.distance / sinFrequency) * 30))
                }
                this.direction = 0;
                this.positions = [];
                for(let i = 0; i < Math.min(this.length, this.scales.length); i++) {
                    this.positions[i] = [- i * this.distance + this.x, this.y];
                }
            }

            reset() {
                if (bestScore < score) bestScore = score;
                localStorage.setItem('bestScore', bestScore);
                document.getElementById('bestscoretext').innerHTML = "Best: " + bestScore;
                score = 0;
                document.getElementById('scoretext').innerHTML = "Score: " + score;
                delete creatures[0];
                creature = new Creature(window.innerWidth / 2, window.innerHeight / 2, scales, distance, speed, rotationSpeed, bodyColor, outlineColor, eyeColor, length);
                creatures[0] = creature;
            }

            addSegments() {
                this.scales = [30, 32, 34, 36, 38];
                for(let i = 0; i < this.length; i++) {
                    if (this.shape == "linear") this.scales.push(Math.abs( 40 - i * 30 / this.length));
                    else if (this.shape == "exp") this.scales.push(Math.abs( 40 - i * 30 / this.length) ** 2)
                    else if (this.shape == "sin") this.scales.push(Math.abs( 40 - Math.sin(i) * 30 / this.length) ** 2)
                }
                for(let i = this.positions.length; i < this.length; i++) {
                    this.positions[i] = [this.positions[this.positions.length - 1][0], this.positions[this.positions.length - 1][1]];
                }
            }

            update() {
                this.collisionDetection();

                if (keys.w) {
                    this.positions[0][0] += Math.cos(this.direction) * this.speed;
                    this.positions[0][1] += Math.sin(this.direction) * this.speed;
                }
                if (keys.a) {
                    this.direction -= this.rotationSpeed / 100;
                    if (!keys.w && !keys.d) {
                        this.positions[0][0] += Math.cos(this.direction) * this.speed/2;
                        this.positions[0][1] += Math.sin(this.direction) * this.speed/2;
                    }
                }
                if (keys.d) {
                    this.direction += this.rotationSpeed / 100;
                    if (!keys.w) {
                        this.positions[0][0] += Math.cos(this.direction) * this.speed/2;
                        this.positions[0][1] += Math.sin(this.direction) * this.speed/2;
                    }
                }

                let dots = [];

                for(let i = 0; i < this.positions.length - 1; i++) {
                    let d = Math.sqrt(Math.pow(this.positions[i + 1][0] - this.positions[i][0], 2) + Math.pow(this.positions[i + 1][1] - this.positions[i][1], 2)) + 1;
                    this.positions[i + 1][0] = this.distance * (this.positions[i + 1][0] - this.positions[i][0]) / d + this.positions[i][0]
                    this.positions[i + 1][1] = this.distance * (this.positions[i + 1][1] - this.positions[i][1]) / d + this.positions[i][1]

                    let vector = [this.positions[i + 1][0] - this.positions[i][0], this.positions[i + 1][1] - this.positions[i][1]]
                    let vectorLength = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2))

                    let vector90 = [vector[1] * this.scales[i] / vectorLength, -vector[0] * this.scales[i] / vectorLength]
                    let vector270 = [-vector[1] * this.scales[i] / vectorLength, vector[0] * this.scales[i] / vectorLength]


                    if (this.drawmode == "lines") {
                        dots.unshift([this.positions[i][0] + vector90[0], this.positions[i][1] + vector90[1]]);
                        dots.push([this.positions[i][0] + vector270[0], this.positions[i][1] + vector270[1]]);
                    }
                    
                    if (this.drawmode == "circles") {
                        ctx.strokeStyle = outlineColor;
                        ctx.fillStyle = bodyColor;
                        ctx.beginPath();
                        ctx.arc(this.positions[i + 1][0], this.positions[i + 1][1], this.scales[i + 1], 0, 2 * Math.PI);
                        ctx.stroke();
                        //ctx.fill();
                        ctx.closePath();
                        ctx.beginPath();
                        ctx.arc(this.positions[i][0], this.positions[i][1], this.scales[i], 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.closePath();
                    }

                    if (this.debug) {
                        // Sides visualization
                        ctx.fillStyle = "white";
                        ctx.beginPath();
                        ctx.arc(this.positions[i][0] + vector90[0], this.positions[i][1] + vector90[1], 3, 0, 2 * Math.PI);
                        ctx.arc(this.positions[i][0] + vector270[0], this.positions[i][1] + vector270[1], 3, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.closePath();
                    }
                }
                let i = this.positions.length - 2

                let vector = [this.positions[i + 1][0] - this.positions[i][0], this.positions[i + 1][1] - this.positions[i][1]]
                let vectorLength = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2))
                
                let vector90 = [vector[1] * this.scales[i + 1] / vectorLength, -vector[0] * this.scales[i + 1] / vectorLength]
                let vector270 = [-vector[1] * this.scales[i + 1] / vectorLength, vector[0] * this.scales[i + 1] / vectorLength]
                
                dots.unshift([this.positions[i + 1][0] + vector90[0], this.positions[i + 1][1] + vector90[1]]);
                dots.push([this.positions[i + 1][0] + vector270[0], this.positions[i + 1][1] + vector270[1]]);

                if (this.shape != "sin") {
                    // Tail outline
                    let rotation = (Math.atan2(vector[1], vector[0]) / (2 * Math.PI)) + 0.25;
                    ctx.strokeStyle = this.outlineColor;
                    ctx.fillStyle = this.bodyColor;
                    ctx.beginPath();
                    ctx.arc(this.positions[i + 1][0], this.positions[i + 1][1], this.scales[i + 1], (rotation - .5) * 2 * Math.PI, rotation * 2 * Math.PI);
                    ctx.stroke();
                    ctx.closePath();
                }

                // body
                ctx.strokeStyle = this.outlineColor;
                ctx.fillStyle = this.bodyColor;
                ctx.beginPath();
                dots.forEach(dot => {
                    ctx.lineTo(dot[0], dot[1]);
                });
                ctx.stroke();
                ctx.fill();
                ctx.closePath();

                if (this.shape != "sin") {
                    // Tail fill
                    ctx.beginPath();
                    ctx.arc(this.positions[i + 1][0], this.positions[i + 1][1], this.scales[i + 1], 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.closePath();
                }

                if (this.debug) {
                    // Body visualization
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.positions[0][0], this.positions[0][1], this.scales[0], 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.closePath();
                    ctx.lineWidth = 10;
                    // Sides visualization
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.arc(this.positions[i + 1][0] + vector90[0], this.positions[i + 1][1] + vector90[1], 3, 0, 2 * Math.PI);
                    ctx.arc(this.positions[i + 1][0] + vector270[0], this.positions[i + 1][1] + vector270[1], 3, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.closePath();
                }

                i = 0

                vector = [this.positions[i + 1][0] - this.positions[i][0], this.positions[i + 1][1] - this.positions[i][1]]
                vectorLength = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2))
                
                // Head
                let rotation = (Math.atan2(vector[1], vector[0]) / (2 * Math.PI)) - 0.25;
                ctx.strokeStyle = this.outlineColor;
                ctx.fillStyle = this.bodyColor;
                ctx.beginPath();
                ctx.arc(this.positions[i][0], this.positions[i][1], this.scales[i], (rotation - .5) * 2 * Math.PI - .1, rotation * 2 * Math.PI + .1);
                ctx.stroke();
                ctx.closePath();
                ctx.beginPath();
                ctx.arc(this.positions[i][0], this.positions[i][1], this.scales[i], 0, 2 * Math.PI + .1);
                ctx.fill();
                ctx.closePath();
                
                if (this.debug) {
                    // Body visualization
                    ctx.strokeStyle = "grey";
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.positions[0][0], this.positions[0][1], this.scales[0], 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.closePath();
                    ctx.lineWidth = 10;
                }

                // Eyes
                ////////vector = [this.positions[i + 1][0] - this.positions[i][0], this.positions[i + 1][1] - this.positions[i][1]]
                vector90 = [vector[1] * this.scales[i] / vectorLength, -vector[0] * this.scales[i] / vectorLength]
                vector270 = [-vector[1] * this.scales[i] / vectorLength, vector[0] * this.scales[i] / vectorLength]
                ctx.fillStyle = this.eyeColor;
                ctx.beginPath();
                ctx.arc(this.positions[i][0] + vector90[0] / 1.3, this.positions[i][1] + vector90[1] / 1.3, 6, 0, 2 * Math.PI);
                ctx.arc(this.positions[i][0] + vector270[0] / 1.3, this.positions[i][1] + vector270[1] / 1.3, 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();

                if (this.debug) {
                    for(let i = 0; i < this.positions.length - 1; i++) {
                        let vector = [this.positions[i + 1][0] - this.positions[i][0], this.positions[i + 1][1] - this.positions[i][1]]
                        let vectorLength = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2))

                        let vector90 = [vector[1] * this.scales[i] / vectorLength, -vector[0] * this.scales[i] / vectorLength]
                        let vector270 = [-vector[1] * this.scales[i] / vectorLength, vector[0] * this.scales[i] / vectorLength]
                        
                        // Body visualization
                        ctx.strokeStyle = "grey";
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(this.positions[i + 1][0], this.positions[i + 1][1], this.scales[i + 1], 0, 2 * Math.PI);
                        ctx.stroke();
                        ctx.closePath();
                        ctx.lineWidth = 10;
                        // Sides visualization
                        ctx.fillStyle = "white";
                        ctx.beginPath();
                        ctx.arc(this.positions[i][0] + vector90[0], this.positions[i][1] + vector90[1], 3, 0, 2 * Math.PI);
                        ctx.arc(this.positions[i][0] + vector270[0], this.positions[i][1] + vector270[1], 3, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }

            collisionDetection() {
                if (this.positions[0][0] > window.innerWidth - this.scales[0] || this.positions[0][0] < this.scales[0] ||
                    this.positions[0][1] > window.innerHeight - this.scales[0] || this.positions[0][1] < this.scales[0]) {
                    this.reset();
                }
                else {
                    for(let i = Math.floor(10 * this.scales[0] / this.distance) + 1; i < this.positions.length; i++) {
                        if (Math.sqrt(Math.pow(this.positions[0][0] - this.positions[i][0], 2) + Math.pow(this.positions[0][1] - this.positions[i][1], 2)) < this.scales[0] + this.scales[i]) {
                            this.reset();
                        }
                    }
                    for(let i = 0; i < 1; i++) {
                        if (Math.sqrt(Math.pow(this.positions[i][0] - apple.x, 2) + Math.pow(this.positions[i][1] - apple.y, 2)) < this.scales[i] + apple.radius) {
                            apple.respawn();
                            score++;
                            if (score > bestScore) bestScore = score;
                            localStorage.setItem('bestScore', bestScore);
                            document.getElementById('scoretext').innerHTML = "Score: " + score;
                            this.length = Math.floor(parseFloat(this.length) * 1.2);
                            console.log(this.length);
                            this.addSegments();
                        }
                    }
                }
            }
        }

        class Apple {
            constructor(x, y, radius, color="red") {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();
            }

            respawn() {
                this.x = 3 * apple.radius + Math.random() * (window.innerWidth - 6 * apple.radius);
                this.y = 3 * apple.radius + Math.random() * (window.innerHeight - 6 * apple.radius);
            }
        }
        
        var apple = new Apple(0, 0, 10, localStorage.getItem('appleColor') || "red");
        apple.respawn();
        var creature = new Creature(window.innerWidth / 2, window.innerHeight / 2, scales, distance, speed, rotationSpeed, bodyColor, outlineColor, eyeColor, length);
        creatures = [creature];
        creature.reset();
        for(let y = 0; y < 0; y++) {
            for(let x = 0; x < 0; x++) {
                //creatures.push(new Creature(window.innerWidth / 2 + x * 100, window.innerHeight / 2 + y * 100, scales, distance, speed, rotationSpeed, bodyColor, outlineColor, eyeColor));
            }
        }

        canvas.onmousemove = (e) => {
            //
        }

        document.onkeydown = (e) => {
            if (e.code == "KeyQ") {
                positions = [];
            }
            if (e.code == "KeyW") {
                keys.w = true;
            }
            if (e.code == "KeyA") {
                keys.a = true;
            }
            if (e.code == "KeyD") {
                keys.d = true;
            }
        }

        document.onkeyup = (e) => {
            if (e.code == "KeyW") {
                keys.w = false;
            }
            if (e.code == "KeyA") {
                keys.a = false;
            }
            if (e.code == "KeyD") {
                keys.d = false;
            }
        }
        
        var updateInterval = setInterval(update, 1000 / 60);
        setInterval(secondUpdate, 1000);

        function update() {
            frames++;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            apple.draw();
            
            creatures.forEach(creature => {
                creature.update();  
            });

            document.getElementById('headpositionx').value = creature.positions[0][0];
            document.getElementById('headpositiony').value = creature.positions[0][1];
        }

        function secondUpdate() {
            document.getElementById('fps').value = frames;
            frames = 0;
        }

    </script>
</body>
</html>